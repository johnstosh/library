# Lessons Learned from Library Management System Development

One key lesson from developing this library management system was the importance of meticulously handling Content-Type headers in frontend API requests to avoid HTTP 415 Unsupported Media Type errors. Initially, the frontend JavaScript fetch calls were sending requests with mismatched Content-Type headers, such as 'text/plain;charset=UTF-8' instead of the expected 'application/json' for JSON payloads, leading to server-side rejection by Spring Boot's @RequestBody deserialization. This highlighted the need for explicit header configuration in functions like postData and putData, ensuring 'Content-Type': 'application/json' is set only for non-FormData requests, while allowing the browser to auto-set 'multipart/form-data' for file uploads. Additionally, distinguishing between form-encoded login submissions (handled by Spring Security) and JSON API calls prevented similar issues in authentication flows. Thorough logging of request/response details in the browser console and server logs was invaluable for debugging, reinforcing the practice of implementing robust error handling and validation early in the development cycle to maintain a seamless user experience across CRUD operations, photo management, and role-based access control.

## Table Layout and Text Overflow

Another important lesson learned was the value of using percentage-based column widths with fixed table layout (`table-fixed`) instead of content-based widths for data tables. Initially, tables used automatic column widths that would expand and wrap text based on content length, leading to inconsistent layouts and poor readability when displaying long titles, names, or descriptions. By standardizing on percentage-based widths (e.g., Title: 45%, Status: 15%, Actions: 15%) and using `overflow-hidden truncate` for text overflow, the tables achieved a cleaner, more predictable appearance. This approach ensures consistent column widths regardless of content length, eliminates text wrapping within cells, improves rendering performance, and provides a more professional user interface. The key insight was that for data tables, predictable layout trumps showing every character of long content - users can click on rows to view full details in modals or detail views. This pattern was successfully applied across all tables in the application (books, authors, users, libraries, loans, etc.) providing a consistent user experience.

## Photo Aspect Ratio Preservation

## TanStack Query isLoading vs Data Availability

A subtle but impactful bug arose from conflating TanStack Query v5's `isLoading` state with whether data was available for display. In TanStack Query v5, `isLoading` is `isPending && isFetching` — `isPending` reflects whether actual data exists, ignoring placeholder data. When using a multi-step caching approach (summaries → batch fetch → cache), the `isLoading` from the batch fetch query would flip to `true` during background refetches even when the application already had all the books to display. This caused the DataTable to replace the entire table with a loading spinner, unmounting all ThrottledThumbnail components and losing their loaded images. The fix was to gate `isLoading` on whether there's actually data to show: `isLoading: allBooks.length === 0 && (summariesLoading || fetchingBooks)`. This ensures the loading spinner only appears during the initial load when no data is available, not during background refetches when books are already displayed. The key insight: `isLoading` from TanStack Query tells you about the query's internal state, but the UI should decide whether to show a spinner based on whether it has data to render.

## Query Key Instability and useRef Stabilization in Multi-Step Queries

When using TanStack Query with multi-step data loading (summaries → batch fetch by IDs → cache), query key instability can cause cascading failures. Specifically, if the query key for a batch fetch includes the IDs being fetched (e.g., `['books', 'byIds', ids.join(',')]`), the key changes every time the ID set changes. During refetches triggered by `staleTime: 0` or reconnect events (`online`), this cascade occurs:

1. Summaries refetch returns same data → `booksToFetch` becomes `[]` (all cached)
2. The byIds query key changes from `[1,2,3,4,5]` to `[]`
3. With `keepPreviousData`, `fetchedBooks` temporarily holds the OLD data (wrong IDs)
4. The `allBooks` useMemo builds from wrong `fetchedBooks` map → books fall through to cache lookup → some return `undefined` → filtered out → `allBooks` shrinks or becomes `[]`

Three fixes work together to prevent this:
- **`placeholderData: keepPreviousData` on summaries query**: Prevents summaries from becoming `undefined` during refetches, which would wipe `allBooks` immediately
- **Remove the guard `if (booksToFetch.length > 0 && !fetchedBooks) return []`**: This guard hides ALL cached books while waiting for new books, causing unnecessary blank states
- **`useRef` stabilization**: A ref preserves the last good `allBooks` array. When `allBooks` transiently becomes `[]` during refetch cascades, the ref provides the previous data so the UI never flickers. The returned data is `allBooks.length > 0 ? allBooks : previousBooksRef.current`

The key insight: in complex multi-step queries, transient empty states are inevitable during refetch cascades. Rather than trying to prevent every edge case, use a ref to guarantee the UI always has data to render. See `grok4-thumbnail-analysis.md` for the full analysis.

## Photo Aspect Ratio Preservation

A critical lesson when displaying photos was understanding the difference between presentation requirements for photos versus other UI elements. Initially, photo thumbnails were displayed using `aspect-square` containers with `object-cover` styling, which forced images into perfect squares by cropping the top and bottom portions. This resulted in users seeing only the middle section of book covers and author photos, losing important visual context. The root issue was treating photos like avatar icons (which benefit from consistent square shapes) rather than content images that should preserve their original aspect ratios. The solution involved removing `aspect-square` from photo containers, changing from `object-cover` to `object-contain`, and using `h-auto` to allow natural height calculation based on the image's aspect ratio. The backend correctly generates thumbnails with preserved aspect ratios (e.g., 400x533 pixels for a 3:4 portrait image), so the frontend must respect these dimensions rather than forcing them into arbitrary shapes. This highlights the importance of matching CSS layout constraints to content requirements - photos are content, not decorative UI elements, and should be displayed with fidelity to their original proportions. The fix also revealed the value of CSS class names like `aspect-square` being self-documenting about their behavior, making it easier to identify when they're being misapplied.
