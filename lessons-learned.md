# Lessons Learned from Library Management System Development

One key lesson from developing this library management system was the importance of meticulously handling Content-Type headers in frontend API requests to avoid HTTP 415 Unsupported Media Type errors. Initially, the frontend JavaScript fetch calls were sending requests with mismatched Content-Type headers, such as 'text/plain;charset=UTF-8' instead of the expected 'application/json' for JSON payloads, leading to server-side rejection by Spring Boot's @RequestBody deserialization. This highlighted the need for explicit header configuration in functions like postData and putData, ensuring 'Content-Type': 'application/json' is set only for non-FormData requests, while allowing the browser to auto-set 'multipart/form-data' for file uploads. Additionally, distinguishing between form-encoded login submissions (handled by Spring Security) and JSON API calls prevented similar issues in authentication flows. Thorough logging of request/response details in the browser console and server logs was invaluable for debugging, reinforcing the practice of implementing robust error handling and validation early in the development cycle to maintain a seamless user experience across CRUD operations, photo management, and role-based access control.

## Table Layout and Text Overflow

Another important lesson learned was the value of using percentage-based column widths with fixed table layout (`table-fixed`) instead of content-based widths for data tables. Initially, tables used automatic column widths that would expand and wrap text based on content length, leading to inconsistent layouts and poor readability when displaying long titles, names, or descriptions. By standardizing on percentage-based widths (e.g., Title: 45%, Status: 15%, Actions: 15%) and using `overflow-hidden truncate` for text overflow, the tables achieved a cleaner, more predictable appearance. This approach ensures consistent column widths regardless of content length, eliminates text wrapping within cells, improves rendering performance, and provides a more professional user interface. The key insight was that for data tables, predictable layout trumps showing every character of long content - users can click on rows to view full details in modals or detail views. This pattern was successfully applied across all tables in the application (books, authors, users, libraries, loans, etc.) providing a consistent user experience.

## Photo Aspect Ratio Preservation

A critical lesson when displaying photos was understanding the difference between presentation requirements for photos versus other UI elements. Initially, photo thumbnails were displayed using `aspect-square` containers with `object-cover` styling, which forced images into perfect squares by cropping the top and bottom portions. This resulted in users seeing only the middle section of book covers and author photos, losing important visual context. The root issue was treating photos like avatar icons (which benefit from consistent square shapes) rather than content images that should preserve their original aspect ratios. The solution involved removing `aspect-square` from photo containers, changing from `object-cover` to `object-contain`, and using `h-auto` to allow natural height calculation based on the image's aspect ratio. The backend correctly generates thumbnails with preserved aspect ratios (e.g., 400x533 pixels for a 3:4 portrait image), so the frontend must respect these dimensions rather than forcing them into arbitrary shapes. This highlights the importance of matching CSS layout constraints to content requirements - photos are content, not decorative UI elements, and should be displayed with fidelity to their original proportions. The fix also revealed the value of CSS class names like `aspect-square` being self-documenting about their behavior, making it easier to identify when they're being misapplied.
